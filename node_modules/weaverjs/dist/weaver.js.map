{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/define.js","src/event.js","src/fabric.js","src/index.js","src/is.js","src/promise.js","src/thread.js","src/util.js","src/window.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACleA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA","file":"weaver.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nvar is = require('./is');\nvar util = require('./util');\nvar Promise = require('./promise');\nvar Event = require('./event');\n\nvar define = {\n\n  // event function reusable stuff\n  event: {\n    regex: /(\\w+)(\\.\\w+)?/, // regex for matching event strings (e.g. \"click.namespace\")\n    optionalTypeRegex: /(\\w+)?(\\.\\w+)?/,\n    falseCallback: function(){ return false; }\n  },\n\n  // event binding\n  on: function( params ){\n    var defaults = {\n      unbindSelfOnTrigger: false,\n      unbindAllBindersOnTrigger: false\n    };\n    params = util.extend({}, defaults, params);\n\n    return function onImpl(events, data, callback){\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n      var eventsIsString = is.string(events);\n      var p = params;\n\n      if( is.fn(data) || data === false ){ // data is actually callback\n        callback = data;\n        data = undefined;\n      }\n\n      // if there isn't a callback, we can't really do anything\n      // (can't speak for mapped events arg version)\n      if( !(is.fn(callback) || callback === false) && eventsIsString ){\n        return self; // maintain chaining\n      }\n\n      if( eventsIsString ){ // then convert to map\n        var map = {};\n        map[ events ] = callback;\n        events = map;\n      }\n\n      for( var evts in events ){\n        callback = events[evts];\n        if( callback === false ){\n          callback = define.event.falseCallback;\n        }\n\n        if( !is.fn(callback) ){ continue; }\n\n        evts = evts.split(/\\s+/);\n        for( var i = 0; i < evts.length; i++ ){\n          var evt = evts[i];\n          if( is.emptyString(evt) ){ continue; }\n\n          var match = evt.match( define.event.regex ); // type[.namespace]\n\n          if( match ){\n            var type = match[1];\n            var namespace = match[2] ? match[2] : undefined;\n\n            var listener = {\n              callback: callback, // callback to run\n              data: data, // extra data in eventObj.data\n              type: type, // the event type (e.g. 'click')\n              namespace: namespace, // the event namespace (e.g. \".foo\")\n              unbindSelfOnTrigger: p.unbindSelfOnTrigger,\n              unbindAllBindersOnTrigger: p.unbindAllBindersOnTrigger,\n              binders: all // who bound together\n            };\n\n            for( var j = 0; j < all.length; j++ ){\n              var _p = all[j]._private;\n\n              _p.listeners = _p.listeners || [];\n              _p.listeners.push( listener );\n            }\n          }\n        } // for events array\n      } // for events map\n\n      return self; // maintain chaining\n    }; // function\n  }, // on\n\n  eventAliasesOn: function( proto ){\n    var p = proto;\n\n    p.addListener = p.listen = p.bind = p.on;\n    p.removeListener = p.unlisten = p.unbind = p.off;\n    p.emit = p.trigger;\n\n    // this is just a wrapper alias of .on()\n    p.pon = p.promiseOn = function( events, selector ){\n      var self = this;\n      var args = Array.prototype.slice.call( arguments, 0 );\n\n      return new Promise(function( resolve, reject ){\n        var callback = function( e ){\n          self.off.apply( self, offArgs );\n\n          resolve( e );\n        };\n\n        var onArgs = args.concat([ callback ]);\n        var offArgs = onArgs.concat([]);\n\n        self.on.apply( self, onArgs );\n      });\n    };\n  },\n\n  off: function offImpl( params ){\n    var defaults = {\n    };\n    params = util.extend({}, defaults, params);\n\n    return function(events, callback){\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n      var eventsIsString = is.string(events);\n\n      if( arguments.length === 0 ){ // then unbind all\n\n        for( var i = 0; i < all.length; i++ ){\n          all[i]._private.listeners = [];\n        }\n\n        return self; // maintain chaining\n      }\n\n      if( eventsIsString ){ // then convert to map\n        var map = {};\n        map[ events ] = callback;\n        events = map;\n      }\n\n      for( var evts in events ){\n        callback = events[evts];\n\n        if( callback === false ){\n          callback = define.event.falseCallback;\n        }\n\n        evts = evts.split(/\\s+/);\n        for( var h = 0; h < evts.length; h++ ){\n          var evt = evts[h];\n          if( is.emptyString(evt) ){ continue; }\n\n          var match = evt.match( define.event.optionalTypeRegex ); // [type][.namespace]\n          if( match ){\n            var type = match[1] ? match[1] : undefined;\n            var namespace = match[2] ? match[2] : undefined;\n\n            for( var i = 0; i < all.length; i++ ){ //\n              var listeners = all[i]._private.listeners = all[i]._private.listeners || [];\n\n              for( var j = 0; j < listeners.length; j++ ){\n                var listener = listeners[j];\n                var nsMatches = !namespace || namespace === listener.namespace;\n                var typeMatches = !type || listener.type === type;\n                var cbMatches = !callback || callback === listener.callback;\n                var listenerMatches = nsMatches && typeMatches && cbMatches;\n\n                // delete listener if it matches\n                if( listenerMatches ){\n                  listeners.splice(j, 1);\n                  j--;\n                }\n              } // for listeners\n            } // for all\n          } // if match\n        } // for events array\n\n      } // for events map\n\n      return self; // maintain chaining\n    }; // function\n  }, // off\n\n  trigger: function( params ){\n    var defaults = {};\n    params = util.extend({}, defaults, params);\n\n    return function triggerImpl(events, extraParams, fnToTrigger){\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n      var eventsIsString = is.string(events);\n      var eventsIsObject = is.plainObject(events);\n      var eventsIsEvent = is.event(events);\n\n      if( eventsIsString ){ // then make a plain event object for each event name\n        var evts = events.split(/\\s+/);\n        events = [];\n\n        for( var i = 0; i < evts.length; i++ ){\n          var evt = evts[i];\n          if( is.emptyString(evt) ){ continue; }\n\n          var match = evt.match( define.event.regex ); // type[.namespace]\n          var type = match[1];\n          var namespace = match[2] ? match[2] : undefined;\n\n          events.push( {\n            type: type,\n            namespace: namespace\n          } );\n        }\n      } else if( eventsIsObject ){ // put in length 1 array\n        var eventArgObj = events;\n\n        events = [ eventArgObj ];\n      }\n\n      if( extraParams ){\n        if( !is.array(extraParams) ){ // make sure extra params are in an array if specified\n          extraParams = [ extraParams ];\n        }\n      } else { // otherwise, we've got nothing\n        extraParams = [];\n      }\n\n      for( var i = 0; i < events.length; i++ ){ // trigger each event in order\n        var evtObj = events[i];\n\n        for( var j = 0; j < all.length; j++ ){ // for each\n          var triggerer = all[j];\n          var listeners = triggerer._private.listeners = triggerer._private.listeners || [];\n          var bubbleUp = false;\n\n          // create the event for this element from the event object\n          var evt;\n\n          if( eventsIsEvent ){ // then just get the object\n            evt = evtObj;\n\n          } else { // then we have to make one\n            evt = new Event( evtObj, {\n              namespace: evtObj.namespace\n            } );\n          }\n\n          if( fnToTrigger ){ // then override the listeners list with just the one we specified\n            listeners = [{\n              namespace: evt.namespace,\n              type: evt.type,\n              callback: fnToTrigger\n            }];\n          }\n\n          for( var k = 0; k < listeners.length; k++ ){ // check each listener\n            var lis = listeners[k];\n            var nsMatches = !lis.namespace || lis.namespace === evt.namespace;\n            var typeMatches = lis.type === evt.type;\n            var targetMatches = true;\n            var listenerMatches = nsMatches && typeMatches && targetMatches;\n\n            if( listenerMatches ){ // then trigger it\n              var args = [ evt ];\n              args = args.concat( extraParams ); // add extra params to args list\n\n              if( lis.data ){ // add on data plugged into binding\n                evt.data = lis.data;\n              } else { // or clear it in case the event obj is reused\n                evt.data = undefined;\n              }\n\n              if( lis.unbindSelfOnTrigger || lis.unbindAllBindersOnTrigger ){ // then remove listener\n                listeners.splice(k, 1);\n                k--;\n              }\n\n              if( lis.unbindAllBindersOnTrigger ){ // then delete the listener for all binders\n                var binders = lis.binders;\n                for( var l = 0; l < binders.length; l++ ){\n                  var binder = binders[l];\n                  if( !binder || binder === triggerer ){ continue; } // already handled triggerer or we can't handle it\n\n                  var binderListeners = binder._private.listeners;\n                  for( var m = 0; m < binderListeners.length; m++ ){\n                    var binderListener = binderListeners[m];\n\n                    if( binderListener === lis ){ // delete listener from list\n                      binderListeners.splice(m, 1);\n                      m--;\n                    }\n                  }\n                }\n              }\n\n              // run the callback\n              var context = triggerer;\n              var ret = lis.callback.apply( context, args );\n\n              if( ret === false || evt.isPropagationStopped() ){\n                // then don't bubble\n                bubbleUp = false;\n\n                if( ret === false ){\n                  // returning false is a shorthand for stopping propagation and preventing the def. action\n                  evt.stopPropagation();\n                  evt.preventDefault();\n                }\n              }\n            } // if listener matches\n          } // for each listener\n\n          if( bubbleUp ){\n            // TODO if bubbling is supported...\n          }\n\n        } // for each of all\n      } // for each event\n\n      return self; // maintain chaining\n    }; // function\n  } // trigger\n\n}; // define\n\nmodule.exports = define;\n","'use strict';\n\n// https://github.com/jquery/jquery/blob/master/src/event.js\n\nvar Event = function( src, props ) {\n  // Allow instantiation without the 'new' keyword\n  if ( !(this instanceof Event) ) {\n    return new Event( src, props );\n  }\n\n  // Event object\n  if ( src && src.type ) {\n    this.originalEvent = src;\n    this.type = src.type;\n\n    // Events bubbling up the document may have been marked as prevented\n    // by a handler lower down the tree; reflect the correct value.\n    this.isDefaultPrevented = ( src.defaultPrevented ) ? returnTrue : returnFalse;\n\n  // Event type\n  } else {\n    this.type = src;\n  }\n\n  // Put explicitly provided properties onto the event object\n  if ( props ) {\n\n    // more efficient to manually copy fields we use\n    this.type = props.type !== undefined ? props.type : this.type;\n    this.namespace = props.namespace;\n    this.layout = props.layout;\n    this.data = props.data;\n    this.message = props.message;\n  }\n\n  // Create a timestamp if incoming event doesn't have one\n  this.timeStamp = src && src.timeStamp || +new Date();\n};\n\nfunction returnFalse() {\n  return false;\n}\nfunction returnTrue() {\n  return true;\n}\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\nEvent.prototype = {\n  instanceString: function(){ return 'event'; },\n\n  preventDefault: function() {\n    this.isDefaultPrevented = returnTrue;\n\n    var e = this.originalEvent;\n    if ( !e ) {\n      return;\n    }\n\n    // if preventDefault exists run it on the original event\n    if ( e.preventDefault ) {\n      e.preventDefault();\n    }\n  },\n\n  stopPropagation: function() {\n    this.isPropagationStopped = returnTrue;\n\n    var e = this.originalEvent;\n    if ( !e ) {\n      return;\n    }\n    // if stopPropagation exists run it on the original event\n    if ( e.stopPropagation ) {\n      e.stopPropagation();\n    }\n  },\n\n  stopImmediatePropagation: function() {\n    this.isImmediatePropagationStopped = returnTrue;\n    this.stopPropagation();\n  },\n\n  isDefaultPrevented: returnFalse,\n  isPropagationStopped: returnFalse,\n  isImmediatePropagationStopped: returnFalse\n};\n\n\nmodule.exports = Event;\n","/*! Weaver licensed under MIT (https://tldrlegal.com/license/mit-license), copyright Max Franz */\n\n'use strict';\n\nvar is = require('./is');\nvar util = require('./util');\nvar Thread = require('./thread');\nvar Promise = require('./promise');\nvar define = require('./define');\n\nvar Fabric = function( N ){\n  if( !(this instanceof Fabric) ){\n    return new Fabric( N );\n  }\n\n  this._private = {\n    pass: []\n  };\n\n  var defN = 4;\n\n  if( is.number(N) ){\n    // then use the specified number of threads\n  } if( typeof navigator !== 'undefined' && navigator.hardwareConcurrency != null ){\n    N = navigator.hardwareConcurrency;\n  } else {\n    try{\n      N = require('os').cpus().length;\n    } catch( err ){\n      N = defN;\n    }\n  } // TODO could use an estimation here but would the additional expense be worth it?\n\n  for( var i = 0; i < N; i++ ){\n    this[i] = new Thread();\n  }\n\n  this.length = N;\n};\n\nvar fabfn = Fabric.prototype; // short alias\n\nutil.extend(fabfn, {\n\n  instanceString: function(){ return 'fabric'; },\n\n  // require fn in all threads\n  require: function( fn, as ){\n    for( var i = 0; i < this.length; i++ ){\n      var thread = this[i];\n\n      thread.require( fn, as );\n    }\n\n    return this;\n  },\n\n  // get a random thread\n  random: function(){\n    var i = Math.round( (this.length - 1) * Math.random() );\n    var thread = this[i];\n\n    return thread;\n  },\n\n  // run on random thread\n  run: function( fn ){\n    var pass = this._private.pass.shift();\n\n    return this.random().pass( pass ).run( fn );\n  },\n\n  // sends a random thread a message\n  message: function( m ){\n    return this.random().message( m );\n  },\n\n  // send all threads a message\n  broadcast: function( m ){\n    for( var i = 0; i < this.length; i++ ){\n      var thread = this[i];\n\n      thread.message( m );\n    }\n\n    return this; // chaining\n  },\n\n  // stop all threads\n  stop: function(){\n    for( var i = 0; i < this.length; i++ ){\n      var thread = this[i];\n\n      thread.stop();\n    }\n\n    return this; // chaining\n  },\n\n  // pass data to be used with .spread() etc.\n  pass: function( data ){\n    var pass = this._private.pass;\n\n    if( is.array(data) ){\n      pass.push( data );\n    } else {\n      throw 'Only arrays may be used with fabric.pass()';\n    }\n\n    return this; // chaining\n  },\n\n  spreadSize: function(){\n    var subsize =  Math.ceil( this._private.pass[0].length / this.length );\n\n    subsize = Math.max( 1, subsize ); // don't pass less than one ele to each thread\n\n    return subsize;\n  },\n\n  // split the data into slices to spread the data equally among threads\n  spread: function( fn ){\n    var self = this;\n    var _p = self._private;\n    var subsize = self.spreadSize(); // number of pass eles to handle in each thread\n    var pass = _p.pass.shift().concat([]); // keep a copy\n    var runPs = [];\n\n    for( var i = 0; i < this.length; i++ ){\n      var thread = this[i];\n      var slice = pass.splice( 0, subsize );\n\n      var runP = thread.pass( slice ).run( fn );\n\n      runPs.push( runP );\n\n      var doneEarly = pass.length === 0;\n      if( doneEarly ){ break; }\n    }\n\n    return Promise.all( runPs ).then(function( thens ){\n      var postpass = [];\n      var p = 0;\n\n      // fill postpass with the total result joined from all threads\n      for( var i = 0; i < thens.length; i++ ){\n        var then = thens[i]; // array result from thread i\n\n        for( var j = 0; j < then.length; j++ ){\n          var t = then[j]; // array element\n\n          postpass[ p++ ] = t;\n        }\n      }\n\n      return postpass;\n    });\n  },\n\n  // parallel version of array.map()\n  map: function( fn ){\n    var self = this;\n\n    self.require( fn, '_$_$_fabmap' );\n\n    return self.spread(function( split ){\n      var mapped = [];\n      var origResolve = resolve; // jshint ignore:line\n\n      resolve = function( val ){ // jshint ignore:line\n        mapped.push( val );\n      };\n\n      for( var i = 0; i < split.length; i++ ){\n        var oldLen = mapped.length;\n        var ret = _$_$_fabmap( split[i] ); // jshint ignore:line\n        var nothingInsdByResolve = oldLen === mapped.length;\n\n        if( nothingInsdByResolve ){\n          mapped.push( ret );\n        }\n      }\n\n      resolve = origResolve; // jshint ignore:line\n\n      return mapped;\n    });\n\n  },\n\n  // parallel version of array.filter()\n  filter: function( fn ){\n    var _p = this._private;\n    var pass = _p.pass[0];\n\n    return this.map( fn ).then(function( include ){\n      var ret = [];\n\n      for( var i = 0; i < pass.length; i++ ){\n        var datum = pass[i];\n        var incDatum = include[i];\n\n        if( incDatum ){\n          ret.push( datum );\n        }\n      }\n\n      return ret;\n    });\n  },\n\n  // sorts the passed array using a divide and conquer strategy\n  sort: function( cmp ){\n    var self = this;\n    var P = this._private.pass[0].length;\n    var subsize = this.spreadSize();\n\n    cmp = cmp || function( a, b ){ // default comparison function\n      if( a < b ){\n        return -1;\n      } else if( a > b ){\n        return 1;\n      }\n\n      return 0;\n    };\n\n    self.require( cmp, '_$_$_cmp' );\n\n    return self.spread(function( split ){ // sort each split normally\n      var sortedSplit = split.sort( _$_$_cmp ); // jshint ignore:line\n      resolve( sortedSplit ); // jshint ignore:line\n\n    }).then(function( joined ){\n      // do all the merging in the main thread to minimise data transfer\n\n      // TODO could do merging in separate threads but would incur add'l cost of data transfer\n      // for each level of the merge\n\n      var merge = function( i, j, max ){\n        // don't overflow array\n        j = Math.min( j, P );\n        max = Math.min( max, P );\n\n        // left and right sides of merge\n        var l = i;\n        var r = j;\n\n        var sorted = [];\n\n        for( var k = l; k < max; k++ ){\n\n          var eleI = joined[i];\n          var eleJ = joined[j];\n\n          if( i < r && ( j >= max || cmp(eleI, eleJ) <= 0 ) ){\n            sorted.push( eleI );\n            i++;\n          } else {\n            sorted.push( eleJ );\n            j++;\n          }\n\n        }\n\n        // in the array proper, put the sorted values\n        for( var k = 0; k < sorted.length; k++ ){ // kth sorted item\n          var index = l + k;\n\n          joined[ index ] = sorted[k];\n        }\n      };\n\n      for( var splitL = subsize; splitL < P; splitL *= 2 ){ // merge until array is \"split\" as 1\n\n        for( var i = 0; i < P; i += 2*splitL ){\n          merge( i, i + splitL, i + 2*splitL );\n        }\n\n      }\n\n      return joined;\n    });\n  }\n\n\n});\n\nvar defineRandomPasser = function( opts ){\n  opts = opts || {};\n\n  return function( fn, arg1 ){\n    var pass = this._private.pass.shift();\n\n    return this.random().pass( pass )[ opts.threadFn ]( fn, arg1 );\n  };\n};\n\nutil.extend(fabfn, {\n  randomMap: defineRandomPasser({ threadFn: 'map' }),\n\n  reduce: defineRandomPasser({ threadFn: 'reduce' }),\n\n  reduceRight: defineRandomPasser({ threadFn: 'reduceRight' })\n});\n\n// aliases\nvar fn = fabfn;\nfn.promise = fn.run;\nfn.terminate = fn.halt = fn.stop;\nfn.include = fn.require;\n\n// pull in event apis\nutil.extend(fabfn, {\n  on: define.on(),\n  one: define.on({ unbindSelfOnTrigger: true }),\n  off: define.off(),\n  trigger: define.trigger()\n});\n\ndefine.eventAliasesOn( fabfn );\n\nmodule.exports = Fabric;\n","'use strict';\n\nvar Thread = require('./thread');\nvar Fabric = require('./fabric');\n\nvar weaver = function(){ // jshint ignore:line\n  return;\n};\n\nweaver.version = '{{VERSION}}';\n\nweaver.thread = weaver.Thread = weaver.worker = weaver.Worker = Thread;\nweaver.fabric = weaver.Fabric = Fabric;\n\nmodule.exports = weaver;\n","// type testing utility functions\n\n'use strict';\n\nvar typeofstr = typeof '';\nvar typeofobj = typeof {};\nvar typeoffn = typeof function(){};\n\nvar instanceStr = function( obj ){\n  return obj && obj.instanceString && is.fn( obj.instanceString ) ? obj.instanceString() : null;\n};\n\nvar is = {\n  defined: function(obj){\n    return obj != null; // not undefined or null\n  },\n\n  string: function(obj){\n    return obj != null && typeof obj == typeofstr;\n  },\n\n  fn: function(obj){\n    return obj != null && typeof obj === typeoffn;\n  },\n\n  array: function(obj){\n    return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;\n  },\n\n  plainObject: function(obj){\n    return obj != null && typeof obj === typeofobj && !is.array(obj) && obj.constructor === Object;\n  },\n\n  object: function(obj){\n    return obj != null && typeof obj === typeofobj;\n  },\n\n  number: function(obj){\n    return obj != null && typeof obj === typeof 1 && !isNaN(obj);\n  },\n\n  integer: function( obj ){\n    return is.number(obj) && Math.floor(obj) === obj;\n  },\n\n  bool: function(obj){\n    return obj != null && typeof obj === typeof true;\n  },\n\n  event: function(obj){\n    return instanceStr(obj) === 'event';\n  },\n\n  thread: function(obj){\n    return instanceStr(obj) === 'thread';\n  },\n\n  fabric: function(obj){\n    return instanceStr(obj) === 'fabric';\n  },\n\n  emptyString: function(obj){\n    if( !obj ){ // null is empty\n      return true;\n    } else if( is.string(obj) ){\n      if( obj === '' || obj.match(/^\\s+$/) ){\n        return true; // empty string is empty\n      }\n    }\n\n    return false; // otherwise, we don't know what we've got\n  },\n\n  nonemptyString: function(obj){\n    if( obj && is.string(obj) && obj !== '' && !obj.match(/^\\s+$/) ){\n      return true;\n    }\n\n    return false;\n  }\n};\n\nmodule.exports = is;\n","// internal, minimal Promise impl s.t. apis can return promises in old envs\n// based on thenable (http://github.com/rse/thenable)\n\n'use strict';\n\n/*  promise states [Promises/A+ 2.1]  */\nvar STATE_PENDING   = 0;                                         /*  [Promises/A+ 2.1.1]  */\nvar STATE_FULFILLED = 1;                                         /*  [Promises/A+ 2.1.2]  */\nvar STATE_REJECTED  = 2;                                         /*  [Promises/A+ 2.1.3]  */\n\n/*  promise object constructor  */\nvar api = function (executor) {\n  /*  optionally support non-constructor/plain-function call  */\n  if (!(this instanceof api))\n    return new api(executor);\n\n  /*  initialize object  */\n  this.id           = \"Thenable/1.0.7\";\n  this.state        = STATE_PENDING; /*  initial state  */\n  this.fulfillValue = undefined;     /*  initial value  */     /*  [Promises/A+ 1.3, 2.1.2.2]  */\n  this.rejectReason = undefined;     /*  initial reason */     /*  [Promises/A+ 1.5, 2.1.3.2]  */\n  this.onFulfilled  = [];            /*  initial handlers  */\n  this.onRejected   = [];            /*  initial handlers  */\n\n  /*  provide optional information-hiding proxy  */\n  this.proxy = {\n    then: this.then.bind(this)\n  };\n\n  /*  support optional executor function  */\n  if (typeof executor === \"function\")\n    executor.call(this, this.fulfill.bind(this), this.reject.bind(this));\n};\n\n/*  promise API methods  */\napi.prototype = {\n  /*  promise resolving methods  */\n  fulfill: function (value) { return deliver(this, STATE_FULFILLED, \"fulfillValue\", value); },\n  reject:  function (value) { return deliver(this, STATE_REJECTED,  \"rejectReason\", value); },\n\n  /*  \"The then Method\" [Promises/A+ 1.1, 1.2, 2.2]  */\n  then: function (onFulfilled, onRejected) {\n    var curr = this;\n    var next = new api();                                    /*  [Promises/A+ 2.2.7]  */\n    curr.onFulfilled.push(\n      resolver(onFulfilled, next, \"fulfill\"));             /*  [Promises/A+ 2.2.2/2.2.6]  */\n    curr.onRejected.push(\n      resolver(onRejected,  next, \"reject\" ));             /*  [Promises/A+ 2.2.3/2.2.6]  */\n    execute(curr);\n    return next.proxy;                                       /*  [Promises/A+ 2.2.7, 3.3]  */\n  }\n};\n\n/*  deliver an action  */\nvar deliver = function (curr, state, name, value) {\n  if (curr.state === STATE_PENDING) {\n    curr.state = state;                                      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */\n    curr[name] = value;                                      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */\n    execute(curr);\n  }\n  return curr;\n};\n\n/*  execute all handlers  */\nvar execute = function (curr) {\n  if (curr.state === STATE_FULFILLED)\n    execute_handlers(curr, \"onFulfilled\", curr.fulfillValue);\n  else if (curr.state === STATE_REJECTED)\n    execute_handlers(curr, \"onRejected\",  curr.rejectReason);\n};\n\n/*  execute particular set of handlers  */\nvar execute_handlers = function (curr, name, value) {\n  /* global setImmediate: true */\n  /* global setTimeout: true */\n\n  /*  short-circuit processing  */\n  if (curr[name].length === 0)\n    return;\n\n  /*  iterate over all handlers, exactly once  */\n  var handlers = curr[name];\n  curr[name] = [];                                             /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */\n  var func = function () {\n    for (var i = 0; i < handlers.length; i++)\n      handlers[i](value);                                  /*  [Promises/A+ 2.2.5]  */\n  };\n\n  /*  execute procedure asynchronously  */                     /*  [Promises/A+ 2.2.4, 3.1]  */\n  if (typeof setImmediate === \"function\")\n    setImmediate(func);\n  else\n    setTimeout(func, 0);\n};\n\n/*  generate a resolver function  */\nvar resolver = function (cb, next, method) {\n  return function (value) {\n    if (typeof cb !== \"function\")                            /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */\n      next[method].call(next, value);                      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */\n    else {\n      var result;\n      try { result = cb(value); }                          /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */\n      catch (e) {\n        next.reject(e);                                  /*  [Promises/A+ 2.2.7.2]  */\n        return;\n      }\n      resolve(next, result);                               /*  [Promises/A+ 2.2.7.1]  */\n    }\n  };\n};\n\n/*  \"Promise Resolution Procedure\"  */                           /*  [Promises/A+ 2.3]  */\nvar resolve = function (promise, x) {\n  /*  sanity check arguments  */                               /*  [Promises/A+ 2.3.1]  */\n  if (promise === x || promise.proxy === x) {\n    promise.reject(new TypeError(\"cannot resolve promise with itself\"));\n    return;\n  }\n\n  /*  surgically check for a \"then\" method\n    (mainly to just call the \"getter\" of \"then\" only once)  */\n  var then;\n  if ((typeof x === \"object\" && x !== null) || typeof x === \"function\") {\n    try { then = x.then; }                                   /*  [Promises/A+ 2.3.3.1, 3.5]  */\n    catch (e) {\n      promise.reject(e);                                   /*  [Promises/A+ 2.3.3.2]  */\n      return;\n    }\n  }\n\n  /*  handle own Thenables    [Promises/A+ 2.3.2]\n    and similar \"thenables\" [Promises/A+ 2.3.3]  */\n  if (typeof then === \"function\") {\n    var resolved = false;\n    try {\n      /*  call retrieved \"then\" method */                  /*  [Promises/A+ 2.3.3.3]  */\n      then.call(x,\n        /*  resolvePromise  */                           /*  [Promises/A+ 2.3.3.3.1]  */\n        function (y) {\n          if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */\n          if (y === x)                                 /*  [Promises/A+ 3.6]  */\n            promise.reject(new TypeError(\"circular thenable chain\"));\n          else\n            resolve(promise, y);\n        },\n\n        /*  rejectPromise  */                            /*  [Promises/A+ 2.3.3.3.2]  */\n        function (r) {\n          if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */\n          promise.reject(r);\n        }\n      );\n    }\n    catch (e) {\n      if (!resolved)                                       /*  [Promises/A+ 2.3.3.3.3]  */\n        promise.reject(e);                               /*  [Promises/A+ 2.3.3.3.4]  */\n    }\n    return;\n  }\n\n  /*  handle other values  */\n  promise.fulfill(x);                                          /*  [Promises/A+ 2.3.4, 2.3.3.4]  */\n};\n\n// use native promises where possible\nvar Promise = typeof Promise === 'undefined' ? api : Promise;\n\n// so we always have Promise.all()\nPromise.all = Promise.all || function( ps ){\n  return new Promise(function( resolveAll, rejectAll ){\n    var vals = new Array( ps.length );\n    var doneCount = 0;\n\n    var fulfill = function( i, val ){\n      vals[i] = val;\n      doneCount++;\n\n      if( doneCount === ps.length ){\n        resolveAll( vals );\n      }\n    };\n\n    for( var i = 0; i < ps.length; i++ ){\n      (function( i ){\n        var p = ps[i];\n        var isPromise = p.then != null;\n\n        if( isPromise ){\n          p.then(function( val ){\n            fulfill( i, val );\n          }, function( err ){\n            rejectAll( err );\n          });\n        } else {\n          var val = p;\n          fulfill( i, val );\n        }\n      })( i );\n    }\n\n  });\n};\n\nmodule.exports = Promise;\n","/*! Weaver licensed under MIT (https://tldrlegal.com/license/mit-license), copyright Max Franz */\n\n// cross-env thread/worker\n// NB : uses (heavyweight) processes on nodejs so best not to create too many threads\n\n'use strict';\n\nvar window = require('./window');\nvar util = require('./util');\nvar Promise = require('./promise');\nvar Event = require('./event');\nvar define = require('./define');\nvar is = require('./is');\n\nvar Thread = function( opts ){\n  if( !(this instanceof Thread) ){\n    return new Thread( opts );\n  }\n\n  var _p = this._private = {\n    requires: [],\n    files: [],\n    queue: null,\n    pass: [],\n    disabled: false\n  };\n\n  if( is.plainObject(opts) ){\n    if( opts.disabled != null ){\n      _p.disabled = !!opts.disabled;\n    }\n  }\n\n};\n\nvar thdfn = Thread.prototype; // short alias\n\nvar stringifyFieldVal = function( val ){\n  var valStr = is.fn( val ) ? val.toString() : \"JSON.parse('\" + JSON.stringify(val) + \"')\";\n\n  return valStr;\n};\n\n// allows for requires with prototypes and subobjs etc\nvar fnAsRequire = function( fn ){\n  var req;\n  var fnName;\n\n  if( is.object(fn) && fn.fn ){ // manual fn\n    req = fnAs( fn.fn, fn.name );\n    fnName = fn.name;\n    fn = fn.fn;\n  } else if( is.fn(fn) ){ // auto fn\n    req = fn.toString();\n    fnName = fn.name;\n  } else if( is.string(fn) ){ // stringified fn\n    req = fn;\n  } else if( is.object(fn) ){ // plain object\n    if( fn.proto ){\n      req = '';\n    } else {\n      req = fn.name + ' = {};';\n    }\n\n    fnName = fn.name;\n    fn = fn.obj;\n  }\n\n  req += '\\n';\n\n  var protoreq = function( val, subname ){\n    if( val.prototype ){\n      var protoNonempty = false;\n      for( var prop in val.prototype ){ protoNonempty = true; break; } // jshint ignore:line\n\n      if( protoNonempty ){\n        req += fnAsRequire( {\n          name: subname,\n          obj: val,\n          proto: true\n        }, val );\n      }\n    }\n  };\n\n  // pull in prototype\n  if( fn.prototype && fnName != null ){\n\n    for( var name in fn.prototype ){\n      var protoStr = '';\n\n      var val = fn.prototype[ name ];\n      var valStr = stringifyFieldVal( val );\n      var subname = fnName + '.prototype.' + name;\n\n      protoStr += subname + ' = ' + valStr + ';\\n';\n\n      if( protoStr ){\n        req += protoStr;\n      }\n\n      protoreq( val, subname ); // subobject with prototype\n    }\n\n  }\n\n  // pull in properties for obj/fns\n  if( !is.string(fn) ){ for( var name in fn ){\n    var propsStr = '';\n\n    if( fn.hasOwnProperty(name) ){\n      var val = fn[ name ];\n      var valStr = stringifyFieldVal( val );\n      var subname = fnName + '[\"' + name + '\"]';\n\n      propsStr += subname + ' = ' + valStr + ';\\n';\n    }\n\n    if( propsStr ){\n      req += propsStr;\n    }\n\n    protoreq( val, subname ); // subobject with prototype\n  } }\n\n  return req;\n};\n\nvar isPathStr = function( str ){\n  return is.string(str) && str.match(/\\.js$/);\n};\n\nutil.extend(thdfn, {\n\n  instanceString: function(){ return 'thread'; },\n\n  require: function( fn, as ){\n    var requires = this._private.requires;\n\n    if( isPathStr(fn) ){\n      this._private.files.push( fn );\n\n      return this;\n    }\n\n    if( as ){\n      if( is.fn(fn) ){\n        fn = { name: as, fn: fn };\n      } else {\n        fn = { name: as, obj: fn };\n      }\n    } else {\n      if( is.fn(fn) ){\n        if( !fn.name ){\n          throw 'The function name could not be automatically determined.  Use thread.require( someFunction, \"someFunction\" )';\n        }\n\n        fn = { name: fn.name, fn: fn };\n      }\n    }\n\n    requires.push( fn );\n\n    return this; // chaining\n  },\n\n  pass: function( data ){\n    this._private.pass.push( data );\n\n    return this; // chaining\n  },\n\n  run: function( fn, pass ){ // fn used like main()\n    var self = this;\n    var _p = this._private;\n    pass = pass || _p.pass.shift();\n\n    if( _p.stopped ){\n      throw 'Attempted to run a stopped thread!  Start a new thread or do not stop the existing thread and reuse it.';\n    }\n\n    if( _p.running ){\n      return ( _p.queue = _p.queue.then(function(){ // inductive step\n        return self.run( fn, pass );\n      }) );\n    }\n\n    var useWW = window != null && !_p.disabled;\n    var useNode = !window && typeof module !== 'undefined' && !_p.disabled;\n\n    self.trigger('run');\n\n    var runP = new Promise(function( resolve, reject ){\n\n      _p.running = true;\n\n      var threadTechAlreadyExists = _p.ran;\n\n      var fnImplStr = is.string( fn ) ? fn : fn.toString();\n\n      // worker code to exec\n      var fnStr = '\\n' + ( _p.requires.map(function( r ){\n        return fnAsRequire( r );\n      }) ).concat( _p.files.map(function( f ){\n        if( useWW ){\n          var wwifyFile = function( file ){\n            if( file.match(/^\\.\\//) || file.match(/^\\.\\./) ){\n              return window.location.origin + window.location.pathname + file;\n            } else if( file.match(/^\\//) ){\n              return window.location.origin + '/' + file;\n            }\n            return file;\n          };\n\n          return 'importScripts(\"' + wwifyFile(f) + '\");';\n        } else if( useNode ) {\n          return 'eval( require(\"fs\").readFileSync(\"' + f + '\", { encoding: \"utf8\" }) );';\n        } else {\n          throw 'External file `' + f + '` can not be required without any threading technology.';\n        }\n      }) ).concat([\n        '( function(){',\n          'var ret = (' + fnImplStr + ')(' + JSON.stringify(pass) + ');',\n          'if( ret !== undefined ){ resolve(ret); }', // assume if ran fn returns defined value (incl. null), that we want to resolve to it\n        '} )()\\n'\n      ]).join('\\n');\n\n      // because we've now consumed the requires, empty the list so we don't dupe on next run()\n      _p.requires = [];\n      _p.files = [];\n\n      if( useWW ){\n        var fnBlob, fnUrl;\n\n        // add normalised thread api functions\n        if( !threadTechAlreadyExists ){\n          var fnPre = fnStr + '';\n\n          fnStr = [\n            'function _ref_(o){ return eval(o); };',\n            'function broadcast(m){ return message(m); };', // alias\n            'function message(m){ postMessage(m); };',\n            'function listen(fn){',\n            '  self.addEventListener(\"message\", function(m){ ',\n            '    if( typeof m === \"object\" && (m.data.$$eval || m.data === \"$$start\") ){',\n            '    } else { ',\n            '      fn( m.data );',\n            '    }',\n            '  });',\n            '};',\n            'self.addEventListener(\"message\", function(m){  if( m.data.$$eval ){ eval( m.data.$$eval ); }  });',\n            'function resolve(v){ postMessage({ $$resolve: v }); };',\n            'function reject(v){ postMessage({ $$reject: v }); };'\n          ].join('\\n');\n\n          fnStr += fnPre;\n\n          fnBlob = new Blob([ fnStr ], {\n            type: 'application/javascript'\n          });\n          fnUrl = window.URL.createObjectURL( fnBlob );\n        }\n        // create webworker and let it exec the serialised code\n        var ww = _p.webworker = _p.webworker || new Worker( fnUrl );\n\n        if( threadTechAlreadyExists ){ // then just exec new run() code\n          ww.postMessage({\n            $$eval: fnStr\n          });\n        }\n\n        // worker messages => events\n        var cb;\n        ww.addEventListener('message', cb = function( m ){\n          var isObject = is.object(m) && is.object( m.data );\n\n          if( isObject && ('$$resolve' in m.data) ){\n            ww.removeEventListener('message', cb); // done listening b/c resolve()\n\n            resolve( m.data.$$resolve );\n          } else if( isObject && ('$$reject' in m.data) ){\n            ww.removeEventListener('message', cb); // done listening b/c reject()\n\n            reject( m.data.$$reject );\n          } else {\n            self.trigger( new Event(m, { type: 'message', message: m.data }) );\n          }\n        }, false);\n\n        if( !threadTechAlreadyExists ){\n          ww.postMessage('$$start'); // start up the worker\n        }\n\n      } else if( useNode ){\n        // create a new process\n\n        if( !_p.child ){\n          _p.child = ( require('child_process').fork( require('path').join(__dirname, 'thread-node-fork') ) );\n        }\n\n        var child = _p.child;\n\n        // child process messages => events\n        var cb;\n        child.on('message', cb = function( m ){\n          if( is.object(m) && ('$$resolve' in m) ){\n            child.removeListener('message', cb); // done listening b/c resolve()\n\n            resolve( m.$$resolve );\n          } else if( is.object(m) && ('$$reject' in m) ){\n            child.removeListener('message', cb); // done listening b/c reject()\n\n            reject( m.$$reject );\n          } else {\n            self.trigger( new Event({}, { type: 'message', message: m }) );\n          }\n        });\n\n        // ask the child process to eval the worker code\n        child.send({\n          $$eval: fnStr\n        });\n\n      } else { // use a fallback mechanism using a timeout\n\n        var promiseResolve = resolve;\n        var promiseReject = reject;\n\n        var timer = _p.timer = _p.timer || {\n\n          listeners: [],\n\n          exec: function(){\n            // as a string so it can't be mangled by minifiers and processors\n            fnStr = [\n              'function _ref_(o){ return eval(o); };',\n              'function broadcast(m){ return message(m); };',\n              'function message(m){ self.trigger( new Event({}, { type: \"message\", message: m }) ); };',\n              'function listen(fn){ timer.listeners.push( fn ); };',\n              'function resolve(v){ promiseResolve(v); };',\n              'function reject(v){ promiseReject(v); };'\n            ].join('\\n') + fnStr;\n\n            // the .run() code\n            eval( fnStr ); // jshint ignore:line\n          },\n\n          message: function( m ){\n            var ls = timer.listeners;\n\n            for( var i = 0; i < ls.length; i++ ){\n              var fn = ls[i];\n\n              fn( m );\n            }\n          }\n\n        };\n\n        timer.exec();\n      }\n\n    }).then(function( v ){\n      _p.running = false;\n      _p.ran = true;\n\n      self.trigger('ran');\n\n      return v;\n    });\n\n    if( _p.queue == null ){\n      _p.queue = runP; // i.e. first step of inductive promise chain (for queue)\n    }\n\n    return runP;\n  },\n\n  // send the thread a message\n  message: function( m ){\n    var _p = this._private;\n\n    if( _p.webworker ){\n      _p.webworker.postMessage( m );\n    }\n\n    if( _p.child ){\n      _p.child.send( m );\n    }\n\n    if( _p.timer ){\n      _p.timer.message( m );\n    }\n\n    return this; // chaining\n  },\n\n  stop: function(){\n    var _p = this._private;\n\n    if( _p.webworker ){\n      _p.webworker.terminate();\n    }\n\n    if( _p.child ){\n      _p.child.kill();\n    }\n\n    if( _p.timer ){\n      // nothing we can do if we've run a timeout\n    }\n\n    _p.stopped = true;\n\n    return this.trigger('stop'); // chaining\n  },\n\n  stopped: function(){\n    return this._private.stopped;\n  }\n\n});\n\n// turns a stringified function into a (re)named function\nvar fnAs = function( fn, name ){\n  var fnStr = fn.toString();\n  fnStr = fnStr.replace(/function\\s*?\\S*?\\s*?\\(/, 'function ' + name + '(');\n\n  return fnStr;\n};\n\nvar defineFnal = function( opts ){\n  opts = opts || {};\n\n  return function fnalImpl( fn, arg1 ){\n    var fnStr = fnAs( fn, '_$_$_' + opts.name );\n\n    this.require( fnStr );\n\n    return this.run( [\n      'function( data ){',\n      '  var origResolve = resolve;',\n      '  var res = [];',\n      '  ',\n      '  resolve = function( val ){',\n      '    res.push( val );',\n      '  };',\n      '  ',\n      '  var ret = data.' + opts.name + '( _$_$_' + opts.name + ( arguments.length > 1 ? ', ' + JSON.stringify(arg1) : '' ) + ' );',\n      '  ',\n      '  resolve = origResolve;',\n      '  resolve( res.length > 0 ? res : ret );',\n      '}'\n    ].join('\\n') );\n  };\n};\n\nutil.extend(thdfn, {\n  reduce: defineFnal({ name: 'reduce' }),\n\n  reduceRight: defineFnal({ name: 'reduceRight' }),\n\n  map: defineFnal({ name: 'map' })\n});\n\n// aliases\nvar fn = thdfn;\nfn.promise = fn.run;\nfn.terminate = fn.halt = fn.stop;\nfn.include = fn.require;\n\n// pull in event apis\nutil.extend(thdfn, {\n  on: define.on(),\n  one: define.on({ unbindSelfOnTrigger: true }),\n  off: define.off(),\n  trigger: define.trigger()\n});\n\ndefine.eventAliasesOn( thdfn );\n\nmodule.exports = Thread;\n","'use strict';\n\nvar is = require('./is');\nvar util;\n\n// utility functions only for internal use\nutil = {\n\n  // the jquery extend() function\n  // NB: modified to use is etc since we can't use jquery functions\n  extend: function() {\n    var options, name, src, copy, copyIsArray, clone,\n      target = arguments[0] || {},\n      i = 1,\n      length = arguments.length,\n      deep = false;\n\n    // Handle a deep copy situation\n    if ( typeof target === 'boolean' ) {\n      deep = target;\n      target = arguments[1] || {};\n      // skip the boolean and the target\n      i = 2;\n    }\n\n    // Handle case when target is a string or something (possible in deep copy)\n    if ( typeof target !== 'object' && !is.fn(target) ) {\n      target = {};\n    }\n\n    // extend jQuery itself if only one argument is passed\n    if ( length === i ) {\n      target = this;\n      --i;\n    }\n\n    for ( ; i < length; i++ ) {\n      // Only deal with non-null/undefined values\n      if ( (options = arguments[ i ]) != null ) {\n        // Extend the base object\n        for ( name in options ) {\n          src = target[ name ];\n          copy = options[ name ];\n\n          // Prevent never-ending loop\n          if ( target === copy ) {\n            continue;\n          }\n\n          // Recurse if we're merging plain objects or arrays\n          if ( deep && copy && ( is.plainObject(copy) || (copyIsArray = is.array(copy)) ) ) {\n            if ( copyIsArray ) {\n              copyIsArray = false;\n              clone = src && is.array(src) ? src : [];\n\n            } else {\n              clone = src && is.plainObject(src) ? src : {};\n            }\n\n            // Never move original objects, clone them\n            target[ name ] = util.extend( deep, clone, copy );\n\n          // Don't bring in undefined values\n          } else if ( copy !== undefined ) {\n            target[ name ] = copy;\n          }\n        }\n      }\n    }\n\n    // Return the modified object\n    return target;\n  },\n\n  error: function( msg ){\n    if( console ){\n      if( console.error ){\n        console.error.apply( console, arguments );\n      } else if( console.log ){\n        console.log.apply( console, arguments );\n      } else {\n        throw msg;\n      }\n    } else {\n      throw msg;\n    }\n  }\n};\n\nmodule.exports = util;\n","module.exports = ( typeof window === 'undefined' ? null : window );\n"]}